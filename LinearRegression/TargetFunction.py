__author__ = 'Andrew'

from numpy.random import random


class TargetFunction(object):
    # domain is [-1,1] x [-1,1]

    # constructor takes a random line that intersects the domain, and declares everything above to be "1",
    # and everything below to be "-1"
    # random line generated by taking two random points
    # member variables
    def __init__(self):
        x1 = -1 + 2 * random()
        x2 = -1 + 2 * random()
        y1 = -1 + 2 * random()
        y2 = -1 + 2 * random()

        self.m = (y2 - y1) / (x2 - x1) #slope
        self.b = y1 - self.m * x1

    #simply evaluates a given data point (x,y), returning 1 or -1 normally but 0 if exactly on the line
    def evaluate(self, x, y):
        result = y - self.m * x - self.b
        if result > 0:
            return 1
        elif result == 0:
            return 0
        else:
            return -1

    #returns a random data point, conveniently never with the result 0
    #returns (x, y, result)
    def getRandomDataPoint(self):
        result = 0
        while result == 0:
            x = -1 + 2 * random()
            y = -1 + 2 * random()
            result = self.evaluate(x,y)
        return (x, y, result)

    #returns a N x 3 array of coefficients (w0, w1, w2) and an N x 1 array of results
    def getTrainingSet(self, size):
        coefficients = [[0]*3 for i in range(size)]
        results = [0] * size
        for i in range(size):
            coefficients[i][0] = 1 #dummy variable for threshold
            dataPoint = self.getRandomDataPoint()
            coefficients[i][1] = dataPoint[0] #x
            coefficients[i][2] = dataPoint[1] #y
            results[i] = dataPoint[2] #result, evaluate(x,y)

        return (coefficients, results)

    def getEIn(self, tripleWeights, coefficients, results):
        counter = 0
        for i in range(len(results)):
            x = coefficients[i][1]
            y = coefficients[i][2]
            result = results[i]
            hypothesizedSum = tripleWeights[0] + (tripleWeights[1] * x) + (tripleWeights[2] * y)
            hypothesizedResult = None
            if (hypothesizedSum == 0):
                hypothesizedResult = 0
            elif (hypothesizedSum > 0):
                hypothesizedResult = 1
            else:
                hypothesizedResult = -1

            if hypothesizedResult != result:
                counter += 1

        return counter / len(results)

    #requires a triple of weights (w0, w1, w2) which give their result based on w0 + w1 x + w2 y > 0
    #returns a decimal which is the approximate error probability of the weights
    def getEOut(self, tripleWeights):
        trials = 1000
        counter = 0
        for i in range(trials):
            dataPoint = self.getRandomDataPoint()
            x = dataPoint[0]
            y = dataPoint[1]
            result = dataPoint[2]
            hypothesizedSum = tripleWeights[0] + (tripleWeights[1] * x) + (tripleWeights[2] * y)
            hypothesizedResult = None
            if (hypothesizedSum == 0):
                hypothesizedResult = 0
            elif (hypothesizedSum > 0):
                hypothesizedResult = 1
            else:
                hypothesizedResult = -1

            if hypothesizedResult != result:
                counter += 1

        return counter / trials







